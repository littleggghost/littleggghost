<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://onevcat.com</id><title>OneV's Den</title><subtitle>上善若水，人淡如菊。这里是王巍 (onevcat) 的博客，用来记录一些技术和想法，主要专注于 Swift 和 iOS 开发。</subtitle> <updated>2023-08-07T13:13:06+09:00</updated> <author> <name>王巍 (onevcat)</name> <uri>https://onevcat.com</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://onevcat.com" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator> <rights> © 2023 王巍 (onevcat) </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>深入理解 Observation - 原理，back porting 和性能</title><link href="https://onevcat.com/2023/08/observation-framework/" rel="alternate" type="text/html" title="深入理解 Observation - 原理，back porting 和性能" /><published>2023-08-07T09:15:00+09:00</published> <updated>2023-08-07T13:13:06+09:00</updated> <id>https://onevcat.com/2023/08/observation-framework/</id> <content src="https://onevcat.com/2023/08/observation-framework/" /> <author> <name>王巍 (onevcat)</name> </author> <category term="能工巧匠集" /> <category term="Swift" /> <summary> SwiftUI 遵循 Single Source of Truth 的原则，只有修改 View 所订阅的状态，才能改变 view tree 并触发对 body 的重新求值，进而刷新 UI。最初发布时，SwiftUI 提供了 @State、@ObservedObject 和 @EnvironmentObject 等属性包装器进行状态管理。在 iOS 14 中，Apple 添加了 @StateObject，它补全了 View 中持有引用类型实例的情况，使得 SwiftUI 的状态管理更加完善。 在订阅引用类型时，ObservableObject 扮演着 Model 类型的角色，但它存在一个严重的问题，即无法提供属性粒度的订阅。在 SwiftUI 的 View 中，对 ObservableObject 的订阅是基于整个实例的。只要 ObservableObject 上的任何一个 @Published 属性发生改变，都会触发整个实例的 objectWillChange 发布者发出变化，进而导致所有订阅了这个对象的 View 进行重新求值。在复杂的 SwiftUI 应用中，这可能会导致严... </summary> </entry> <entry><title>一些关于开发的杂谈话题 - 测试</title><link href="https://onevcat.com/2023/04/dev-talk-testing/" rel="alternate" type="text/html" title="一些关于开发的杂谈话题 - 测试" /><published>2023-04-06T22:15:00+09:00</published> <updated>2023-08-07T13:13:06+09:00</updated> <id>https://onevcat.com/2023/04/dev-talk-testing/</id> <content src="https://onevcat.com/2023/04/dev-talk-testing/" /> <author> <name>王巍 (onevcat)</name> </author> <category term="能工巧匠集" /> <category term="Swift" /> <summary> 最近接手了一些陈旧项目的维护工作，需要把一部分质量很烂的代码进行重构甚至重写。在这个过程期间，我也有机会对一些开发中比较重要的而且通用的知识进行了一点重新的思考和整理，在这里想把它们用个两三篇文章，以杂谈的方式记录一下。这些内容在我刚入门程序开发的时候困扰过我一段时间，所以虽然可能对于已经有多年经验的大佬们用处不大，但是希望新入行的同学们能通过这些话题得到一些启发，如果能减少走弯路的时间，那就更好了。 今天的第一个话题是有关测试的。在以前，我也写过一些关于测试的文章，不过更多的还是对某个特定框架的使用。我自己本身也在很长一段时间内保持了给包括框架和 app 写测试的习惯，并来回倒腾过不少不同风格的测试。在这篇短文里，我想对一些基本的问题和想法的变化进行解释。 为什么要写测试？你会给项目和代码写测试吗？ 这是一个每次我去参加各种技术分享会，在结束后的自由交流环节经常会被问到的问题。 我很理解由于工期紧张、需求变动频繁等原因，导致的对测试有意无意的忽视。但在这里，我还是想给出一个关于写测试的理由的答案。如果整篇文章只有一句话值得被记住，那就是： 合理的测试保证了开发者的生活... </summary> </entry> <entry><title>不知所谓的 2022 年终总结</title><link href="https://onevcat.com/2022/12/2022-final/" rel="alternate" type="text/html" title="不知所谓的 2022 年终总结" /><published>2022-12-31T12:10:00+09:00</published> <updated>2023-08-07T13:13:06+09:00</updated> <id>https://onevcat.com/2022/12/2022-final/</id> <content src="https://onevcat.com/2022/12/2022-final/" /> <author> <name>王巍 (onevcat)</name> </author> <category term="一得之愚集" /> <summary> 其实随着年龄增长，总感觉最近每年都很平淡，也几乎没有什么肉眼可见的进步。再加上疫情到了第三年，自己又长期在宅工作，无形中少了许多和这个世界接触的机会，更让自己的思想越来越僵化死板。不知道是不是因为长年在日本这种国度的关系，从感觉上来说似乎这个世界固化住了。一种即视感萦绕在周围，自己却没有什么新思路，也找不到突破的方式。如何才能在这种情况下继续前进，想来应该会成为今后重要的课题。 这篇年终总结一下笔，居然发现自己整一年都脑袋空空，实在是很不应该。既然没有什么特别想要写的，那就还是先按照每个月挑选一张照片配上说明，来简单回顾一下这一整年吧。一是抒发一下心绪，二来也算是一种见证。最后阶段会依照惯例补充一些今年的书籍、动漫和游戏。 如果硬要说自己对比去年有什么不同的话，大概两鬓新增的白发在寒风中所诉说的故事就是一切了。 图说 一月 姐妹两人操作香菱，帮助爸爸在璃月大地上做任务打工升级。 电子游戏早已是成熟的第九艺术，顶级的游戏必然有着顶级的图像、音乐以及故事。游戏早已是我人生中无法抹掉的印记。相比于用一些冰冷的法律法规，设置重重阻碍来限制她们的游戏时间，还不如多多引导，主... </summary> </entry> <entry><title>Swift 正则速查手册</title><link href="https://onevcat.com/2022/11/swift-regex/" rel="alternate" type="text/html" title="Swift 正则速查手册" /><published>2022-11-15T23:00:00+09:00</published> <updated>2023-08-07T13:13:06+09:00</updated> <id>https://onevcat.com/2022/11/swift-regex/</id> <content src="https://onevcat.com/2022/11/swift-regex/" /> <author> <name>王巍 (onevcat)</name> </author> <category term="能工巧匠集" /> <category term="Swift" /> <summary> Swift 5.7 中引入了正则表达式的语法支持，整理一下相关的一些话题、方法和示例，以备今后自己能够速查。 总览 Swift 正则由标准库中的 Regex 类型驱动，需要 iOS 16.0 或 macOS 13.0，早期的 deploy 版本无法使用。 构建一个正则表达式的方式，分为传统的正则字面量构建，以及通过 Regex Builder DSL 的更加易读的方式。后者可以内嵌使用前者，以及其他一些已有的 parser，在可读性和功能上要强力很多。实践中，推荐结合使用字面量和 Builder API 在简洁和易读之间获取平衡。 常见字面量 和其他各语言正则表达式的字面量没有显著不同。 直接将字面量包裹在 /.../ 中使用，Swift 将把类似的声明转换为 Regex 类型的实例： 1 let bitcoinAddress_v1 = /([13][a-km-zA-HJ-NP-Z0-9]{26,33})/ 一些常用的字面量表达以及示例。更多非常用的例子，可以参考这里的 Cheat Sheet。 字符集 表达式 ... </summary> </entry> <entry><title>Xcode 中使用 SPM 和 Build Configuration 的一些坑</title><link href="https://onevcat.com/2022/10/spm-in-xcode/" rel="alternate" type="text/html" title="Xcode 中使用 SPM 和 Build Configuration 的一些坑" /><published>2022-10-14T11:00:00+09:00</published> <updated>2023-08-07T13:13:06+09:00</updated> <id>https://onevcat.com/2022/10/spm-in-xcode/</id> <content src="https://onevcat.com/2022/10/spm-in-xcode/" /> <author> <name>王巍 (onevcat)</name> </author> <category term="能工巧匠集" /> <category term="SwiftUI" /> <summary> TL;DR 当前，在 Xcode 中使用 Swift Package Manager 的包时，SPM 在编译 package 时将参照 Build Configuration 的名字，自动选择使用 debug 还是 release 来编译，这决定了像是 DEBUG 这样的编译 flag 以及最终的二进制产品的架构。在 Xcode 中使用默认的 “Debug” 和 “Release” 之外的自定义的 Build Configuration 时，这个自动选择可能会造成问题。 现在 (2022 年 10 月) 还并没有特别好的方式将 Xcode 中 Build Configuration 映射到 SPM 的编译环境中去。希望未来版本的 Xcode 和 SPM 能有所改善。 关于文中的一些例子，可以在这里找到源码。 Xcode 和 SPM 中的编译条件 默认的 DEBUG 编译条件 在 Xcode 中，创建项目时我们会自动得到两个 Build Configuration：Debug 和 Release。 在 SWIFT_ACTIVE_COMPILATION_CONDIT... </summary> </entry> </feed>
